Here is a detailed, step-by-step plan to build your "Ingredient Shield" app.

This plan focuses on creating a **Progressive Web App (PWA)**. This is the most efficient approach: you build *one* application using Next.js (React) that works as both a website and an installable mobile app on all devices. This single codebase handles everything, all hosted for $0.

**Core Tech Stack (All Free Tiers):**

  * **Hosting:** Vercel (for the web app)
  * **Database & Auth:** Supabase (PostgreSQL, User Auth)
  * **Backend Logic:** Supabase Edge Functions (Deno/TypeScript)
  * **Frontend:** Next.js (React)
  * **Barcode Scanning:** `zxing-js` (a JavaScript library)
  * **Data Source:** Open Food Facts API

-----

### Phase 1: Setup & Database (Approx. 2 hours)

**Step 1: Accounts & Workspace Setup (30 min)**

1.  **Install Tools:** Ensure you have `VS Code`, `Node.js` (v18+), and `Git` installed.
2.  **Install CLIs:** Open your terminal and run `npm i -g vercel supabase`.
3.  **Create Accounts:**
      * Sign up for a free [GitHub](https://github.com/) account (to store your code).
      * Sign up for a free [Supabase](https://supabase.com/) account (for database/auth).
      * Sign up for a free [Vercel](https://vercel.com/) account *using your GitHub account*. This makes deployment automatic.

**Step 2: Initialize Project & Database (30 min)**

1.  **Create Supabase Project:** In your Supabase dashboard, create a new project. Name it `ingredient-shield` and save your **Database Password** securely.
2.  **Initialize Next.js App:** In your terminal, run `npx create-next-app@latest -e with-supabase ingredient-shield-app`. This official template sets up a Next.js app with the Supabase client already configured.
3.  **Initialize Git:** `cd ingredient-shield-app`, run `git init`, `git add .`, and `git commit -m "initial commit"`.
4.  **Create GitHub Repo:** Create a new, empty repository on GitHub (e.g., `ingredient-shield`).
5.  **Push Code:** Follow the commands on GitHub to link your local code to the repo (e.g., `git remote add origin ...` and `git push -u origin main`).

**Step 3: Link Vercel & Deploy (30 min)**

1.  **Import Project:** In your Vercel dashboard, click "Add New... Project." Select the `ingredient-shield` GitHub repository you just created.
2.  **Configure Env Vars:** Vercel will detect it's a Supabase project. It will ask for two keys. Find them in your Supabase project settings (`Settings > API`):
      * `NEXT_PUBLIC_SUPABASE_URL` (the `Project URL`)
      * `NEXT_PUBLIC_SUPABASE_ANON_KEY` (the `anon` `public` key)
3.  **Deploy:** Click "Deploy." Vercel will build and host your app. You now have a live URL\!

**Step 4: Design Database Schema (30 min)**

1.  **Go to Supabase:** In your Supabase dashboard, go to the `SQL Editor`.
2.  **Create Tables:** Create a new query and run the following SQL. This sets up your user profiles and the rules.
    ```sql
    -- Create table for public user profiles
    create table profiles (
      id uuid references auth.users(id) on delete cascade primary key,
      username text unique
    );

    -- Function to create a profile when a new user signs up
    create function public.handle_new_user()
    returns trigger
    language plpgsql
    security definer set search_path = public
    as $$
    begin
      insert into public.profiles (id)
      values (new.id);
      return new;
    end;
    $$;

    -- Trigger to run the function on user creation
    create trigger on_auth_user_created
      after insert on auth.users
      for each row execute procedure public.handle_new_user();

    -- Create an ENUM type for rule categories
    create type rule_type as enum ('allergy', 'ethics', 'health', 'preference');

    -- Create the main rules table
    create table rules (
      id bigint generated by default as identity primary key,
      profile_id uuid references public.profiles(id) on delete cascade not null,
      type rule_type not null,
      value text not null,
      created_at timestamptz default now(),
      unique(profile_id, type, value) -- A user can't have the same rule twice
    );

    -- Enable Row Level Security (RLS)
    alter table profiles enable row level security;
    alter table rules enable row level security;

    -- Create RLS policies
    create policy "Profiles are viewable by everyone."
      on profiles for select using (true);

    create policy "Users can insert their own profile."
      on profiles for insert with check (auth.uid() = id);

    create policy "Users can manage their own rules."
      on rules for all
      using (auth.uid() = profile_id);
    ```

-----

### Phase 2: Backend & Rules Engine (Approx. 1.5 hours)

**Step 5: Backend Function Setup (30 min)**

1.  **Link Supabase CLI:** In your terminal (in the app folder), run `supabase login` and then `supabase link --project-ref <YOUR_PROJECT_ID>` (find ID in your Supabase project URL).
2.  **Create Function:** Run `supabase functions new check-product`. This creates a `supabase/functions/check-product` folder.
3.  **Edit `index.ts`:** Open `supabase/functions/check-product/index.ts`. This is your backend. Replace the contents with this starter code. This sets up the function, handles CORS (so your Vercel app can call it), and gets the barcode.
    ```typescript
    import { serve } from "https://deno.land/std@0.168.0/http/server.ts"

    // This is your Rules Engine!
    async function runRulesEngine(productIngredients: string, userRules: any[]) {
      const violations: string[] = [];
      const ingredientsLower = productIngredients.toLowerCase();

      for (const rule of userRules) {
        const ruleValueLower = rule.value.toLowerCase();
        
        // This is a simple MVP check.
        // You'll expand this in Step 12.
        if (ingredientsLower.includes(ruleValueLower)) {
          violations.push(rule.value);
        }
      }
      return violations;
    }

    serve(async (req) => {
      // Handle CORS preflight requests
      if (req.method === "OPTIONS") {
        return new Response("ok", {
          headers: {
            "Access-Control-Allow-Origin": "*", // Be more specific in prod
            "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
          },
        });
      }

      try {
        const { barcode } = await req.json();
        if (!barcode) throw new Error("Barcode is required");

        // 1. Get user from auth header
        // (We will add this in a later step, for now it's public)

        // 2. Fetch product from Open Food Facts
        const offResponse = await fetch(`https://world.openfoodfacts.org/api/v2/product/${barcode}.json`);
        if (!offResponse.ok) throw new Error("Product not found");
        
        const productData = await offResponse.json();
        const ingredients = productData.product?.ingredients_text || "";
        const productName = productData.product?.product_name || "Unknown Product";

        // 3. Get user's rules (Mocked for now)
        // In a real step, you'd fetch this from Supabase DB based on user auth
        const mockUserRules = [
          { type: 'allergy', value: 'peanuts' },
          { type: 'ethics', value: 'palm oil' }
        ];

        // 4. Run the rules engine
        const violations = await runRulesEngine(ingredients, mockUserRules);

        const status = violations.length > 0 ? "red" : "green";

        const data = {
          status,
          violations,
          productName,
          ingredients,
        };

        return new Response(JSON.stringify(data), {
          headers: {
            "Access-Control-Allow-Origin": "*",
            "Content-Type": "application/json",
          },
        });

      } catch (error) {
        return new Response(JSON.stringify({ error: error.message }), {
          status: 400,
          headers: {
            "Access-Control-Allow-Origin": "*",
            "Content-Type": "application/json",
          },
        });
      }
    })
    ```

**Step 6: Deploy & Test Backend Function (30 min)**

1.  **Deploy Function:** In your terminal, run `supabase functions deploy check-product --no-verify-jwt`. (The flag skips auth for now, making it easy to test).
2.  **Test Function:** You can use Postman, or even your browser's console, to test the deployed function.
      * Find your function's URL in the Supabase dashboard (`Edge Functions > check-product`).
      * Use a tool to make a `POST` request to that URL with a JSON body like:
        `{ "barcode": "737628064502" }` (This is a barcode for Jif Peanut Butter).
      * You should get a JSON response:
        `{"status":"red","violations":["peanuts"],"productName":"Jif Creamy Peanut Butter",...}`

-----

### Phase 3: Frontend & Mobile App (Approx. 2.5 hours)

**Step 7: Auth & Profile Page (30 min)**

1.  **Auth UI:** The `with-supabase` template you used already has login/signup pages. Test them\! Sign up for an account on your live Vercel URL. You'll see a new user in your Supabase `auth.users` table.
2.  **Create Profile Page:** Create a new file: `app/profile/page.tsx`. This will be the main screen for managing rules.
3.  **Build UI:** Use React Server Components to fetch rules and Server Actions to add/delete them. This is the modern, secure way.
    ```tsx
    // app/profile/page.tsx
    import { createServerComponentClient } from '@supabase/auth-helpers-nextjs'
    import { cookies } from 'next/headers'
    import { redirect } from 'next/navigation'

    // Simple form to add a rule
    async function AddRuleForm() {
      const addRule = async (formData: FormData) => {
        'use server'
        const ruleValue = formData.get('rule_value') as string;
        const ruleType = formData.get('rule_type') as string;
        
        const cookieStore = cookies()
        const supabase = createServerComponentClient({ cookies: () => cookieStore })
        const { data: { user } } = await supabase.auth.getUser()
        
        if (user && ruleValue && ruleType) {
          await supabase.from('rules').insert({ 
            profile_id: user.id, 
            value: ruleValue, 
            type: ruleType 
          });
          // This will re-render the page
        }
      }

      return (
        <form action={addRule} className="flex gap-2">
          <input name="rule_value" placeholder="e.g., Peanuts" className="border p-2" />
          <select name="rule_type" className="border p-2">
            <option value="allergy">Allergy</option>
            <option value="ethics">Ethics</option>
            <option value="health">Health</option>
            <option value="preference">Preference</option>
          </select>
          <button type="submit" className="bg-blue-500 text-white p-2">Add Rule</button>
        </form>
      )
    }

    export default async function Profile() {
      const cookieStore = cookies()
      const supabase = createServerComponentClient({ cookies: () => cookieStore })
      const { data: { user } } = await supabase.auth.getUser()

      if (!user) {
        redirect('/login')
      }

      const { data: rules } = await supabase
        .from('rules')
        .select('*')
        .eq('profile_id', user.id);

      return (
        <div className="p-4">
          <h1 className="text-xl font-bold">Your Rules</h1>
          <AddRuleForm />
          <ul className="mt-4 space-y-2">
            {rules?.map(rule => (
              <li key={rule.id} className="p-2 border rounded">
                <span className="font-bold">{rule.type}:</span> {rule.value}
              </li>
            ))}
          </ul>
        </div>
      )
    }
    ```

**Step 8: Barcode Scanner Component (30 min)**

1.  **Install Library:** `npm install @zxing/library`
2.  **Create Component:** Create a *client component* file: `app/components/BarcodeScanner.tsx`.
    ```tsx
    // app/components/BarcodeScanner.tsx
    'use client'
    import { BrowserMultiFormatReader, NotFoundException } from '@zxing/library';
    import { useEffect, useRef, useState } from 'react';

    interface BarcodeScannerProps {
      onScan: (result: string) => void;
    }

    export default function BarcodeScanner({ onScan }: BarcodeScannerProps) {
      const videoRef = useRef<HTMLVideoElement>(null);
      const [error, setError] = useState('');

      useEffect(() => {
        const codeReader = new BrowserMultiFormatReader();
        
        codeReader.listVideoInputDevices()
          .then(videoInputDevices => {
            if (videoInputDevices.length > 0 && videoRef.current) {
              // Use the back camera
              const firstDeviceId = videoInputDevices[videoInputDevices.length - 1].deviceId;
              
              codeReader.decodeFromVideoStream(firstDeviceId, videoRef.current)
                .then(result => {
                  onScan(result.getText());
                })
                .catch(err => {
                  if (!(err instanceof NotFoundException)) {
                    setError('Error scanning: ' + err);
                  }
                });
            } else {
              setError('No video devices found.');
            }
          })
          .catch(err => setError('Error listing devices: ' + err));

        return () => {
          codeReader.reset();
        };
      }, [onScan]);

      return (
        <div>
          <video ref={videoRef} className="w-full h-64 border bg-black" />
          {error && <p className="text-red-500">{error}</p>}
        </div>
      );
    }
    ```

**Step 9: Create Scan & Result Pages (30 min)**

1.  **Create Scan Page:** Create `app/scan/page.tsx`. This page will show the scanner.
    ```tsx
    // app/scan/page.tsx
    'use client'
    import { useRouter } from 'next/navigation'
    import BarcodeScanner from '../components/BarcodeScanner'

    export default function ScanPage() {
      const router = useRouter();

      const handleScan = async (barcode: string) => {
        // Here, you'll call your function
        // For now, just navigate with the barcode
        router.push(`/result?barcode=${barcode}`);
      };

      return (
        <div className="p-4">
          <h1 className="text-xl font-bold mb-4">Scan a Barcode</h1>
          <BarcodeScanner onScan={handleScan} />
        </div>
      );
    }
    ```
2.  **Create Result Page:** Create `app/result/page.tsx`. This page will show the result.
    ```tsx
    // app/result/page.tsx
    'use client'
    import { useSearchParams } from 'next/navigation'
    import { useEffect, useState } from 'react'

    export default function ResultPage() {
      const searchParams = useSearchParams();
      const barcode = searchParams.get('barcode');
      const [result, setResult] = useState<any>(null);
      const [isLoading, setIsLoading] = useState(true);

      useEffect(() => {
        if (barcode) {
          // This is where you call your Supabase function!
          // Replace with your function URL
          const FUNCTION_URL = 'YOUR_SUPABASE_FUNCTION_URL';
          
          fetch(FUNCTION_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ barcode })
          })
          .then(res => res.json())
          .then(data => {
            setResult(data);
            setIsLoading(false);
          });
        }
      }, [barcode]);

      if (isLoading) return <div className="p-4">Loading...</div>
      if (result?.error) return <div className="p-4">Error: {result.error}</div>

      const isGreen = result.status === 'green';

      return (
        <div className={`p-4 min-h-screen ${isGreen ? 'bg-green-100' : 'bg-red-100'}`}>
          <h1 className={`text-4xl font-bold ${isGreen ? 'text-green-700' : 'text-red-700'}`}>
            {isGreen ? 'All Clear!' : 'Warning!'}
          </h1>
          <h2 className="text-xl mt-2">{result.productName}</h2>
          
          {!isGreen && (
            <div className="mt-4">
              <h3 className="font-bold">Violates {result.violations.length} rules:</h3>
              <ul className="list-disc list-inside">
                {result.violations.map((v: string) => <li key={v}>{v}</li>)}
              </ul>
            </div>
          )}
        </div>
      )
    }
    ```

-----

### Phase 4: Integration & Refinement (Approx. 1.5 hours)

**Step 10: Secure the Backend Function (30 min)**

1.  **Redeploy Function:** Go back to `supabase/functions/check-product/index.ts`.
      * **Remove `--no-verify-jwt`:** Deploy by running `supabase functions deploy check-product`. Now it requires auth.
      * **Get User & Rules:** Replace the `mockUserRules` section with real data:
        ```typescript
        // ...inside the try block...
        // 1. Create Supabase client with user's auth token
        const authHeader = req.headers.get("Authorization")!;
        const supabaseClient = createClient(
          Deno.env.get("SUPABASE_URL") ?? "",
          Deno.env.get("SUPABASE_ANON_KEY") ?? "",
          { global: { headers: { Authorization: authHeader } } }
        );

        // 2. Get the user
        const { data: { user } } = await supabaseClient.auth.getUser();
        if (!user) throw new Error("User not authenticated");

        // 3. Get user's rules
        const { data: userRules, error: rulesError } = await supabaseClient
          .from("rules")
          .select("type, value")
          .eq("profile_id", user.id);

        if (rulesError) throw new Error(rulesError.message);

        // ... rest of the code ...
        // 4. Run the rules engine (pass real userRules)
        const violations = await runRulesEngine(ingredients, userRules || []);
        // ...
        ```
2.  **Call Secured Function:** In `app/result/page.tsx`, you must now pass the auth token.
      * Install the client helper: `npm install @supabase/auth-helpers-react`
      * Wrap your app in `app/layout.tsx` with the provider.
      * In `result/page.tsx`, get the token and pass it:
        ```tsx
        // ... in result/page.tsx
        import { useSession, useSupabaseClient } from '@supabase/auth-helpers-react'

        // ... inside component
        const session = useSession();

        // ... inside useEffect
        if (barcode && session) {
          fetch(FUNCTION_URL, {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${session.access_token}` // Pass the token!
            },
            body: JSON.stringify({ barcode })
          })
          // ...
        }
        ```

**Step 11: Make it an Installable PWA (30 min)**

1.  **Install PWA Helper:** `npm install @next-pwa/root`
2.  **Configure:** Follow the `@next-pwa` setup to add a `manifest.json` and service worker. This is what prompts users on mobile to "Add to Home Screen," making it feel like a native app.
3.  **Add Manifest:** Create a `public/manifest.json` file to define your app's name, icon, and colors.
    ```json
    {
      "name": "Ingredient Shield",
      "short_name": "Shield",
      "start_url": "/",
      "display": "standalone",
      "background_color": "#ffffff",
      "theme_color": "#000000",
      "icons": [
        { "src": "/icon-192x192.png", "sizes": "192x192", "type": "image/png" },
        { "src": "/icon-512x512.png", "sizes": "512x512", "type": "image/png" }
      ]
    }
    ```
4.  **Add Icons:** Add the corresponding `icon-192x192.png` and `icon-512x512.png` to your `public/` folder.

**Step 12: Refine the Rules Engine (The "Super Useful" Part) (30 min)**

1.  **The Problem:** Your current engine (Step 5) only checks `ingredients.includes('palm oil')`. This is too simple. "Palm Oil" can be "Palm Kernel Oil," "Palmitate," or "Vegetable Oil (Palm)."
2.  **The Solution:** Create a new table for synonyms.
    ```sql
    -- Run this in your Supabase SQL Editor
    create table ingredient_mappings (
      id bigint generated by default as identity primary key,
      rule_value text not null unique, -- e.g., "palm_oil"
      synonyms text[] -- e.g., {"palm kernel oil", "palmitate", "sodium lauryl palmitate"}
    );

    -- Add some data
    insert into ingredient_mappings (rule_value, synonyms)
    values 
      ('palm oil', '{"palm kernel oil", "palmitate", "vegetable oil (palm)"}'),
      ('peanuts', '{"peanut", "groundnut", "arachide"}');
    ```
3.  **Update Function:** In your `check-product` function, update the `runRulesEngine` to be much smarter. It now needs to fetch these mappings and check against all synonyms. This is the core logic of your entire app. `git push` to deploy all your changes.

You now have a fully functional, $0-cost, hyper-personalized food scanner that works on both desktop and mobile.